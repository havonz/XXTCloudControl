# 需要仓库管理员设置的 Secrets：
# - DOCKERHUB_USERNAME：Docker Hub 用户名
# - DOCKERHUB_TOKEN：Docker Hub Access Token
# - DOCKERHUB_REPO：Docker Hub 仓库名（可选，默认 xxtcloudcontrol）
# - GHCR_REPO：GHCR 仓库名（可选，默认 xxtcloudcontrol）

name: Release (Manual)

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "仅构建与打包，不登录/推送镜像、不创建 GitHub Release"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"
      release_notes:
        description: "本次发布更新日志（可选，支持多行；会追加在自动生成 Release Notes 前）"
        required: false
        type: string

jobs:
  build-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: server/go.mod
          cache: true

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: ${{ inputs.dry_run != 'true' }}
        uses: docker/login-action@v3
        with:
          # 来自仓库 Secrets
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: ${{ inputs.dry_run != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          # GITHUB_TOKEN 为 Actions 自动注入（需 packages: write 权限）
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set build metadata
        run: |
          set -euo pipefail
          BUILD_TIME="$(date -u '+%Y%m%d%H%M')"
          VERSION="v$(date -u '+%Y%m%d%H%M')"
          COMMIT="$(git rev-parse --short HEAD)"
          {
            echo "BUILD_TIME=$BUILD_TIME"
            echo "VERSION=$VERSION"
            echo "COMMIT=$COMMIT"
          } >> "$GITHUB_ENV"

      - name: Generate icons from SVG
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y librsvg2-bin
          chmod +x generate-icons.sh
          ./generate-icons.sh

      - name: Build frontend
        run: |
          set -euo pipefail
          cd frontend
          npm ci
          npm run build

      - name: Build and package releases
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          RELEASE_DIR="$ROOT/release"
          FRONTEND_DIST="$ROOT/frontend/dist"

          if [ ! -d "$FRONTEND_DIST" ]; then
            echo "Error: frontend build output not found at $FRONTEND_DIST" >&2
            exit 1
          fi

          LDFLAGS="-X 'main.BuildTime=$BUILD_TIME' -X 'main.Version=$VERSION' -X 'main.Commit=$COMMIT'"

          platforms=(
            "linux/amd64"
            "linux/arm64"
            "windows/amd64"
            "windows/arm64"
            "darwin/amd64"
            "darwin/arm64"
          )

          for platform in "${platforms[@]}"; do
            IFS='/' read -r GOOS GOARCH <<< "$platform"

            BIN="xxtcloudserver-$GOOS-$GOARCH"
            if [ "$GOOS" = "windows" ]; then
              BIN="${BIN}.exe"
            fi

            echo "Building $GOOS/$GOARCH..."
            (cd "$ROOT/server" && env CGO_ENABLED=0 GOOS="$GOOS" GOARCH="$GOARCH" go build -ldflags "$LDFLAGS" -o "$RELEASE_DIR/$BIN" .)

            PACKAGE_DIR="$RELEASE_DIR/.package/$GOOS-$GOARCH"
            PACKAGE_ROOT="$PACKAGE_DIR/XXTCloudControl"
            mkdir -p "$PACKAGE_ROOT/frontend"
            cp "$RELEASE_DIR/$BIN" "$PACKAGE_ROOT/"
            cp -R "$FRONTEND_DIST"/. "$PACKAGE_ROOT/frontend/"

            ZIP_NAME="XXTCloudControl-$VERSION-$GOOS-$GOARCH.zip"
            ZIP_PATH="$RELEASE_DIR/$ZIP_NAME"
            (cd "$PACKAGE_DIR" && zip -r "$ZIP_PATH" "XXTCloudControl" >/dev/null)
          done

          ls -la "$RELEASE_DIR"/*.zip

      - name: Build docker images (amd64/arm64)
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          RELEASE_DIR="$ROOT/release"
          FRONTEND_DIST="$ROOT/frontend/dist"

          for arch in amd64 arm64; do
            OUTPUT_TAR="$RELEASE_DIR/XXTCloudControl-docker-$VERSION-linux-$arch.tar"
            DOCKER_BUILD_DIR="$RELEASE_DIR/.docker-$arch"

            mkdir -p "$DOCKER_BUILD_DIR"
            cp "$RELEASE_DIR/xxtcloudserver-linux-$arch" "$DOCKER_BUILD_DIR/"
            cp -R "$FRONTEND_DIST" "$DOCKER_BUILD_DIR/frontend"
            cp Dockerfile.release "$DOCKER_BUILD_DIR/Dockerfile"

            docker buildx build \
              --platform "linux/$arch" \
              --build-arg TARGETARCH="$arch" \
              -t "xxtcloudcontrol:$VERSION-$arch" \
              --output "type=docker,dest=$OUTPUT_TAR" \
              "$DOCKER_BUILD_DIR"

            rm -rf "$DOCKER_BUILD_DIR"
          done

          ls -la "$RELEASE_DIR"/*.tar

      - name: Generate update metadata (manifest/checksums/latest)
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          RELEASE_DIR="$ROOT/release"
          CHECKSUMS_PATH="$RELEASE_DIR/checksums.txt"
          MANIFEST_PATH="$RELEASE_DIR/update-manifest.json"
          LATEST_PATH="$RELEASE_DIR/latest.txt"
          REPO="$GITHUB_REPOSITORY"
          TAG="$VERSION"
          DOWNLOAD_BASE_URL="https://github.com/$REPO/releases/download/$TAG"
          LATEST_BASE_URL="https://github.com/$REPO/releases/latest/download"
          PUBLISHED_AT="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          LINUX_AMD64_ZIP="XXTCloudControl-$TAG-linux-amd64.zip"
          LINUX_ARM64_ZIP="XXTCloudControl-$TAG-linux-arm64.zip"
          WINDOWS_AMD64_ZIP="XXTCloudControl-$TAG-windows-amd64.zip"
          WINDOWS_ARM64_ZIP="XXTCloudControl-$TAG-windows-arm64.zip"
          DARWIN_AMD64_ZIP="XXTCloudControl-$TAG-darwin-amd64.zip"
          DARWIN_ARM64_ZIP="XXTCloudControl-$TAG-darwin-arm64.zip"
          DOCKER_AMD64_TAR="XXTCloudControl-docker-$TAG-linux-amd64.tar"
          DOCKER_ARM64_TAR="XXTCloudControl-docker-$TAG-linux-arm64.tar"

          cd "$RELEASE_DIR"
          sha256sum \
            "$LINUX_AMD64_ZIP" \
            "$LINUX_ARM64_ZIP" \
            "$WINDOWS_AMD64_ZIP" \
            "$WINDOWS_ARM64_ZIP" \
            "$DARWIN_AMD64_ZIP" \
            "$DARWIN_ARM64_ZIP" \
            "$DOCKER_AMD64_TAR" \
            "$DOCKER_ARM64_TAR" \
            > "$CHECKSUMS_PATH"

          checksum_for() {
            local file="$1"
            awk -v f="$file" '$2==f {print $1}' "$CHECKSUMS_PATH"
          }

          cat > "$MANIFEST_PATH" <<EOF
          {
            "version": "$TAG",
            "channel": "stable",
            "buildTime": "$BUILD_TIME",
            "commit": "$COMMIT",
            "publishedAt": "$PUBLISHED_AT",
            "checksumsUrl": "$DOWNLOAD_BASE_URL/checksums.txt",
            "latestChecksumsUrl": "$LATEST_BASE_URL/checksums.txt",
            "assets": [
              {
                "os": "linux",
                "arch": "amd64",
                "name": "$LINUX_AMD64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$LINUX_AMD64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$LINUX_AMD64_ZIP",
                "sha256": "$(checksum_for "$LINUX_AMD64_ZIP")"
              },
              {
                "os": "linux",
                "arch": "arm64",
                "name": "$LINUX_ARM64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$LINUX_ARM64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$LINUX_ARM64_ZIP",
                "sha256": "$(checksum_for "$LINUX_ARM64_ZIP")"
              },
              {
                "os": "windows",
                "arch": "amd64",
                "name": "$WINDOWS_AMD64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$WINDOWS_AMD64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$WINDOWS_AMD64_ZIP",
                "sha256": "$(checksum_for "$WINDOWS_AMD64_ZIP")"
              },
              {
                "os": "windows",
                "arch": "arm64",
                "name": "$WINDOWS_ARM64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$WINDOWS_ARM64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$WINDOWS_ARM64_ZIP",
                "sha256": "$(checksum_for "$WINDOWS_ARM64_ZIP")"
              },
              {
                "os": "darwin",
                "arch": "amd64",
                "name": "$DARWIN_AMD64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$DARWIN_AMD64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$DARWIN_AMD64_ZIP",
                "sha256": "$(checksum_for "$DARWIN_AMD64_ZIP")"
              },
              {
                "os": "darwin",
                "arch": "arm64",
                "name": "$DARWIN_ARM64_ZIP",
                "url": "$DOWNLOAD_BASE_URL/$DARWIN_ARM64_ZIP",
                "latestUrl": "$LATEST_BASE_URL/$DARWIN_ARM64_ZIP",
                "sha256": "$(checksum_for "$DARWIN_ARM64_ZIP")"
              }
            ],
            "dockerAssets": [
              {
                "os": "linux",
                "arch": "amd64",
                "name": "$DOCKER_AMD64_TAR",
                "url": "$DOWNLOAD_BASE_URL/$DOCKER_AMD64_TAR",
                "latestUrl": "$LATEST_BASE_URL/$DOCKER_AMD64_TAR",
                "sha256": "$(checksum_for "$DOCKER_AMD64_TAR")"
              },
              {
                "os": "linux",
                "arch": "arm64",
                "name": "$DOCKER_ARM64_TAR",
                "url": "$DOWNLOAD_BASE_URL/$DOCKER_ARM64_TAR",
                "latestUrl": "$LATEST_BASE_URL/$DOCKER_ARM64_TAR",
                "sha256": "$(checksum_for "$DOCKER_ARM64_TAR")"
              }
            ]
          }
          EOF

          cat > "$LATEST_PATH" <<EOF
          version=$TAG
          published_at=$PUBLISHED_AT
          manifest_url=$LATEST_BASE_URL/update-manifest.json
          checksums_url=$LATEST_BASE_URL/checksums.txt
          EOF

          ls -la "$RELEASE_DIR"/update-manifest.json "$RELEASE_DIR"/checksums.txt "$RELEASE_DIR"/latest.txt

      - name: Push docker images to Docker Hub + GHCR (amd64/arm64)
        if: ${{ inputs.dry_run != 'true' }}
        env:
          # 来自仓库 Secrets
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_REPO: ${{ secrets.DOCKERHUB_REPO }}
          GHCR_REPO: ${{ secrets.GHCR_REPO }}
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          RELEASE_DIR="$ROOT/release"
          if [ -z "${DOCKERHUB_USERNAME:-}" ]; then
            echo "Error: DOCKERHUB_USERNAME is not set." >&2
            exit 1
          fi

          IMAGE_REPO="${DOCKERHUB_REPO:-xxtcloudcontrol}"
          IMAGE_DH="${DOCKERHUB_USERNAME}/${IMAGE_REPO}"
          GHCR_REPO_NAME="${GHCR_REPO:-xxtcloudcontrol}"
          IMAGE_GH="ghcr.io/${GITHUB_REPOSITORY_OWNER}/${GHCR_REPO_NAME}"
          DOCKER_IMAGE_NAME="xxtcloudcontrol"

          # Reuse built tar artifacts to avoid rebuilding the same images again.
          for arch in amd64 arm64; do
            TAR_PATH="$RELEASE_DIR/XXTCloudControl-docker-$VERSION-linux-$arch.tar"
            if [ ! -f "$TAR_PATH" ]; then
              echo "Error: docker artifact not found: $TAR_PATH" >&2
              exit 1
            fi

            docker load -i "$TAR_PATH"

            docker tag "$DOCKER_IMAGE_NAME:$VERSION-$arch" "$IMAGE_DH:$VERSION-$arch"
            docker tag "$DOCKER_IMAGE_NAME:$VERSION-$arch" "$IMAGE_GH:$VERSION-$arch"

            docker push "$IMAGE_DH:$VERSION-$arch"
            docker push "$IMAGE_GH:$VERSION-$arch"
          done

          docker manifest rm "$IMAGE_DH:$VERSION" >/dev/null 2>&1 || true
          docker manifest create "$IMAGE_DH:$VERSION" \
            "$IMAGE_DH:$VERSION-amd64" \
            "$IMAGE_DH:$VERSION-arm64"
          docker manifest push "$IMAGE_DH:$VERSION"

          docker manifest rm "$IMAGE_DH:latest" >/dev/null 2>&1 || true
          docker manifest create "$IMAGE_DH:latest" \
            "$IMAGE_DH:$VERSION-amd64" \
            "$IMAGE_DH:$VERSION-arm64"
          docker manifest push "$IMAGE_DH:latest"

          docker manifest rm "$IMAGE_GH:$VERSION" >/dev/null 2>&1 || true
          docker manifest create "$IMAGE_GH:$VERSION" \
            "$IMAGE_GH:$VERSION-amd64" \
            "$IMAGE_GH:$VERSION-arm64"
          docker manifest push "$IMAGE_GH:$VERSION"

          docker manifest rm "$IMAGE_GH:latest" >/dev/null 2>&1 || true
          docker manifest create "$IMAGE_GH:latest" \
            "$IMAGE_GH:$VERSION-amd64" \
            "$IMAGE_GH:$VERSION-arm64"
          docker manifest push "$IMAGE_GH:latest"

      - name: Create GitHub Release (auto notes)
        if: ${{ inputs.dry_run != 'true' && inputs.release_notes == '' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: ${{ env.VERSION }}
          generate_release_notes: true
          files: |
            release/XXTCloudControl-*.zip
            release/XXTCloudControl-docker-*.tar
            release/update-manifest.json
            release/checksums.txt
            release/latest.txt
          fail_on_unmatched_files: true

      - name: Create GitHub Release (custom notes)
        if: ${{ inputs.dry_run != 'true' && inputs.release_notes != '' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: ${{ env.VERSION }}
          body: ${{ inputs.release_notes }}
          generate_release_notes: true
          files: |
            release/XXTCloudControl-*.zip
            release/XXTCloudControl-docker-*.tar
            release/update-manifest.json
            release/checksums.txt
            release/latest.txt
          fail_on_unmatched_files: true

      - name: Trigger Pages workflow
        if: ${{ inputs.dry_run != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'release-pages',
              client_payload: {
                release_tag: process.env.VERSION
              }
            });
            core.info(`Triggered repository_dispatch release-pages for ${process.env.VERSION}`);
