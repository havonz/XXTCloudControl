import { AuthService } from './AuthService';

type AuthPayload = {
  ts: number;
  nonce: string;
  sign: string;
};

let apiBaseUrl = '';

const isAuthDebugEnabled = (): boolean => {
  try {
    if (typeof localStorage !== 'undefined' && localStorage.getItem('xxt_auth_debug') === '1') {
      return true;
    }
  } catch {
    // ignore
  }
  return Boolean(import.meta?.env?.VITE_XXT_AUTH_DEBUG);
};

const logAuthDebug = (message: string, payload: Record<string, unknown>) => {
  if (!isAuthDebugEnabled()) return;
  try {
    console.log(message, payload);
  } catch {
    // ignore
  }
};

export const setApiBaseUrl = (baseUrl: string) => {
  apiBaseUrl = baseUrl.trim().replace(/\/+$/, '');
};

const isAbsoluteUrl = (url: string): boolean => {
  return /^https?:\/\//i.test(url) || url.startsWith('//');
};

const resolveUrl = (url: string): string => {
  if (isAbsoluteUrl(url) || !apiBaseUrl) return url;
  if (url.startsWith('/')) return `${apiBaseUrl}${url}`;
  return `${apiBaseUrl}/${url}`;
};

const buildCanonicalPath = (url: URL): string => {
  const params = new URLSearchParams(url.search);
  params.delete('ts');
  params.delete('nonce');
  params.delete('sign');

  const keys = Array.from(new Set(Array.from(params.keys()))).sort();
  const sorted = new URLSearchParams();
  for (const key of keys) {
    const values = params.getAll(key).sort();
    for (const value of values) {
      sorted.append(key, value);
    }
  }

  const query = sorted.toString();
  return query ? `${url.pathname}?${query}` : url.pathname;
};

const computeBodyHash = async (authService: AuthService, body?: BodyInit | null): Promise<string> => {
  if (!body) return '';

  if (typeof body === 'string') {
    return authService.sha256HexFromString(body);
  }

  if (body instanceof URLSearchParams) {
    return authService.sha256HexFromString(body.toString());
  }

  if (body instanceof Uint8Array) {
    return authService.sha256HexFromBytes(body);
  }

  if (body instanceof ArrayBuffer) {
    return authService.sha256HexFromBytes(new Uint8Array(body));
  }

  if (body instanceof Blob) {
    const buffer = await body.arrayBuffer();
    return authService.sha256HexFromBytes(new Uint8Array(buffer));
  }

  if (body instanceof FormData) {
    // Multipart body boundary is generated by fetch, cannot be reproduced reliably here.
    return '';
  }

  if (typeof ReadableStream !== 'undefined' && body instanceof ReadableStream) {
    throw new Error('ReadableStream body not supported for auth signing');
  }

  return authService.sha256HexFromString(authService.stableStringify(body));
};

const buildAuthPayload = (
  authService: AuthService,
  method: string,
  url: string,
  bodyHash: string
): AuthPayload | null => {
  const credentials = authService.getCurrentCredentials();
  if (!credentials?.password) {
    return null;
  }
  const ts = authService.getServerTimestamp();
  const nonce = authService.generateNonce();
  const urlObj = new URL(resolveUrl(url), window.location.origin);
  const canonicalPath = buildCanonicalPath(urlObj);
  const sign = authService.generateHttpSignature(
    credentials.password,
    ts,
    nonce,
    method,
    canonicalPath,
    bodyHash
  );
  logAuthDebug('[auth][http] signature', {
    method,
    canonicalPath,
    ts,
    nonce,
    bodyHash,
    sign,
  });
  return { ts, nonce, sign };
};

const getAuthPayload = async (
  method: string,
  url: string,
  body?: BodyInit | null
): Promise<AuthPayload | null> => {
  const authService = AuthService.getInstance();
  const bodyHash = await computeBodyHash(authService, body);
  return buildAuthPayload(authService, method, url, bodyHash);
};

export const withAuthHeaders = async (url: string, options: RequestInit = {}): Promise<Headers> => {
  const result = new Headers(options.headers);
  const method = (options.method || 'GET').toUpperCase();
  const payload = await getAuthPayload(method, url, options.body as BodyInit | null | undefined);
  if (payload) {
    result.set('X-XXT-TS', String(payload.ts));
    result.set('X-XXT-Nonce', payload.nonce);
    result.set('X-XXT-Sign', payload.sign);
  }
  return result;
};

export const authFetch = async (url: string, options: RequestInit = {}) => {
  const headers = await withAuthHeaders(url, options);
  return fetch(resolveUrl(url), { ...options, headers });
};

export const appendAuthQuery = (url: string): string => {
  const authService = AuthService.getInstance();
  const payload = buildAuthPayload(authService, 'GET', url, '');
  if (!payload) {
    return resolveUrl(url);
  }
  const finalUrl = new URL(resolveUrl(url), window.location.origin);
  finalUrl.searchParams.set('ts', String(payload.ts));
  finalUrl.searchParams.set('nonce', payload.nonce);
  finalUrl.searchParams.set('sign', payload.sign);
  return finalUrl.toString();
};
